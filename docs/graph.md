# 그래프 알고리즘 (MST와 최단 경로)

최소 신장 트리(MST)와 최단 경로 알고리즘(다익스트라) 비교 설명


## 1. MST (Minimum Spanning Tree, 최소 신장 트리)

그래프의 모든 정점을 사이클 없이 연결하는 간선들의 집합을 "신장 트리"라고 합니다. 가중치 그래프에서 이 간선들의 가중치 합이 최소가 되는 신장 트리를 "최소 신장 트리"라고 합니다.

* **핵심 속성**: 정점 개수가 $V$개일 때, MST는 항상 $V-1$개의 간선으로 구성됩니다.
* **목표**: 전체 연결 비용의 최소화 (예: 모든 도시를 잇는 최소 길이의 도로망 구축)


## 2. 크루스칼 알고리즘 (Kruskal's Algorithm)

MST를 만드는 알고리즘 중 하나로, `간선 중심(Edge-based)`의 Greedy 접근 방식입니다.
> 가장 비용이 적게 드는 간선부터 차례대로 연결하자. 단, 사이클이 생기면 안 된다.

### 동작 원리

1.  **간선 정렬**: 그래프의 모든 간선을 가중치(비용) 기준으로 오름차순 정렬합니다.
2.  **간선 선택**: 정렬된 간선을 순서대로 하나씩 확인합니다.
3.  **사이클 확인**: 현재 간선을 선택했을 때, 이 간선이 연결하는 두 정점이 **이미 같은 집합에 속해 있는지 확인**합니다. (사이클 형성 여부 확인)
    * **같은 집합이라면?** 이 간선을 추가하면 사이클이 되므로 **무시합니다.**
    * **다른 집합이라면?** 이 간선을 MST에 **포함시키고**, 두 정점이 속한 집합을 **하나로 합칩니다(Union).**
4.  **종료**: $V-1$개의 간선이 선택될 때까지 반복합니다.

### 핵심 자료구조

* **Disjoint Set (Union-Find)**: 사이클 생성 여부를 빠르게 확인하고 집합을 합치기 위해 필수적으로 사용됩니다.

### 시간 복잡도

* $O(E \log E)$ (간선 정렬 시간이 지배적. $E$: 간선 개수)

---

## 3. 프림 알고리즘 (Prim's Algorithm)

MST를 만드는 또 다른 알고리즘으로, `정점 중심(Vertex-based)`의 Greedy 접근 방식입니다.
> 하나의 정점에서 시작해서, 현재까지 연결된 정점들로부터 가장 가까운 정점을 계속해서 붙여나가자.

### 동작 원리

1.  **시작 정점 선택**: 임의의 정점 하나를 MST에 포함시키며 시작합니다.
2.  **간선 탐색**: 현재 MST에 포함된 정점들과 **아직 포함되지 않은 정점들**을 연결하는 모든 간선 중에서 가중치가 가장 작은 간선을 찾습니다.
3.  **정점 추가**: 찾은 간선과 연결된 새로운 정점을 MST에 포함시킵니다.
4.  **반복**: 모든 정점이 MST에 포함될 때까지 2~3번 과정을 반복합니다.

### 핵심 자료구조

* **Priority Queue (우선순위 큐)**: 현재 MST에서 외부로 나가는 간선들 중 최소 가중치 간선을 빠르게 찾기 위해 사용됩니다.

### 시간 복잡도

* $O(E \log V)$ (우선순위 큐 사용 시. $V$: 정점 개수)

---

## 4. 다익스트라 알고리즘 (Dijkstra's Algorithm)

MST 알고리즘과 목적이 다릅니다. 다익스트라는 **최단 경로**를 찾는 알고리즘입니다.

* **핵심 아이디어**: "시작점에서부터 거리가 확정된 정점들을 기준으로, 인접한 정점들의 최단 거리를 계속해서 갱신해 나가자."

### 동작 원리

1.  **초기화**: 시작 정점의 거리는 0, 나머지 모든 정점의 거리는 무한대($\infty$)로 설정합니다. 거리 정보를 저장할 배열(distance table)을 준비합니다.
2.  **우선순위 큐 활용**: 우선순위 큐에 `(거리, 정점 번호)`를 넣습니다. 시작점으로 `(0, start_node)`를 넣고 시작합니다.
3.  **최단 거리 확정**: 큐에서 현재까지의 거리가 가장 짧은 정점 `u`를 꺼냅니다. 이 정점 `u`의 최단 거리는 **확정**됩니다.
4.  **거리 갱신 (Relaxation)**: 정점 `u`와 인접한 모든 정점 `v`에 대해, 기존에 알려진 `v`까지의 거리보다 `u`를 거쳐 `v`로 가는 거리 (`distance[u] + weight(u, v)`)가 더 짧다면, `distance[v]` 값을 갱신하고 우선순위 큐에 `(갱신된 거리, v)`를 넣습니다.
5.  **반복**: 큐가 빌 때까지 반복합니다.

### 중요 제약사항

* 간선의 가중치가 **음수이면 사용할 수 없습니다.**

### 시간 복잡도

* $O(E \log V)$ (우선순위 큐 사용 시)

---

## 요약 비교

| 알고리즘 | 목적 | 핵심 전략 | 시간 복잡도 (PQ/Union-Find 사용) |
| :--- | :--- | :--- | :--- |
| **크루스칼** | **MST** (최소 연결 비용) | **간선** 중심: 비용이 낮은 간선부터 선택 (사이클 방지) | `O(E logE)` |
| **프림** | **MST** (최소 연결 비용) | **정점** 중심: 연결된 집합에서 가장 가까운 정점 확장 | `O(E logV)` |
| **다익스트라** | **최단 경로** (시작점 $\to$ 모든 점) | **거리** 중심: 시작점에서 가장 가까운 순서로 거리 확정 | `O(E logV)` |